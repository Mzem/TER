\input{../tex/preambule}
\usepackage[french,frenchkw,ruled]{../tex/algorithm2e}

\title{\vspace{\fill}\textbf{\Huge Rapport}}
\author{
	Sonny Klotz - Idir Hamad - Younes Benyamna - Malek Zemni
	\vspace{2em}\\
	\textit{Projet M1 Informatique}\\\textit{Primalité}
	\vspace{2em}
}

\begin{document}
\pagenumbering{gobble}\clearpage
\maketitle\vspace{9em}
\begin{center}\includegraphics[scale=0.7]{logo.png}\end{center}
\begin{flushright}Module \textit{TER}\end{flushright}
\newpage
\tableofcontents
\newpage\clearpage\pagenumbering{arabic}

	\section*{Introduction}
	
	\paragraph{}Ce document est le compte-rendu final de notre projet sur les tests de primalité qui s'inscrit dans le cadre du module \textit{TER} du M1 informatique de l'\textit{UVSQ}.
	\paragraph{}Les tests de primalité sont des algorithmes qui permettent de savoir si un nombre entier est premier. Ces tests sont indispensables pour la cryptographie à clé publique.
	\paragraph{}Il existe plusieurs algorithmes de tests de primalité. L'efficacité de ces algorithmes est particulièrement liée au cryptosystème utilisé. 
	\paragraph{}Notre travail consiste donc à implémenter différents tests de primalité et de comparer leurs performances.
	\paragraph{}Dans la première partie de ce document, on présentera l'architecture de notre application, illustrée par un organigramme.\\
	Ensuite, on parlera des principaux cryptosystèmes faisant appel à des tests de primalité. \\
	La troisième partie traitera des différents algorithmes de tests de primalité implémentés.\\
	Les mesures de performance et le comparatif des tests de primalités seront détaillés dans la quatrième partie.\\
	Finalement, on établira un bilan technique de notre projet, quant à l'application, à l'organisation interne au sein du groupe et aux coûts.
	
	\section{Architecture de l'application}
		\subsection{Organigramme et données échangées}
		Cet organigramme représente la décomposition en modules de l'application, ainsi que les informations qui circulent entre ces modules.
		
		\subsection{Fonctionnalités des modules}
		
		\subsection{Outils et langages de programmation}
		Notre application va être implémentée dans le langage \lstinline!C!. Le langage \lstinline!C! possède plusieurs types pour représenter des nombre entiers. Cependant, tous ces types ont une précision fixe et ne peuvent pas dépasser un certain nombre d'octets. Le type le plus grand est le \lstinline!long long int! qui peut contenir des entiers d'un taille maximale de 64 bits. Or, tous ces types sont beaucoup trop courts pour les applications cryptographiques qui nécessitent la manipulation de données d'au moins 512 bits.
		\paragraph{}\lstinline!GNU MP! pour \lstinline!GNU Multi Precision!, souvent appelée \lstinline!GMP! est une bibliothèque \lstinline!C!/\lstinline!C++! de calcul multiprécision sur des nombres entiers, rationnels et à virgule flottante qui permet en particulier de manipuler de très grand nombres.
	
	\section{Cryptosystèmes}
		Les tests de primalité sont des algorithmes indispensables pour la cryptographie à clé publique. Ces tests sont couramment utilisés par les cryptosystèmes \textbf{\textit{RSA}} et \textbf{\textit{ElGamal}}.\\
		Pour \textit{RSA}, les tests sont effectués lors la phase de génération de clés. Pour \textit{ElGamal}, ils sont effectués lors de l'établissement d'un échange de clés.
		
		\subsection{RSA}
		
		\subsection{ElGamal}
		
		
	\section{Tests de primalité}
		Les tests de primalité sont des algorithmes qui permettent de savoir si un nombre entier est premier. Dans le cas où le nombre n'est pas premier, il est dit \textbf{\textit{composé}}. Dans cette partie, on va détailler les différents algorithmes de tests de primalité traités. Pour chaque test, on donnera un bref historique, l'algorithme du test, sa complexité et sa preuve, puis son implémentation.\\
		Les tests de primalité peuvent être
		\begin{itemize}
			\item \textbf{déterministes :} fournissent toujours la même réponse pour un nombre donné
			\item \textbf{probabilistes :} peuvent fournir des réponses différentes pour un même nombre (utilisent des données tirées aléatoirement)
		\end{itemize}
		
		\subsection{Test de Fermat}
			Le test de Fermat est un test de primalité probabiliste basé sur le \textit{petit théorème de Fermat}.
			\newtheorem*{Fermat}{Petit théorème de Fermat}
			\vspace{-1.5em}\begin{adjustwidth}{1.5cm}{1.5cm} 
			\begin{Fermat}
				si $p$ est un nombre premier, alors pour tout nombre entier $a$ premier avec $p$
				\[a^{p-1}\equiv 1 \pmod p\]
			\end{Fermat}
			\end{adjustwidth}\vspace{0.5em}
			
			\subsubsection{Algorithme}
				Le théorème de Fermat décrit une propriété commune à tous les nombres premiers qui peut être utilisée pour détecter si un nombre est premier ou bien composé.\\
				En effet, si pour un entier $a$ premier avec $n$ : 
				\begin{itemize}
				\item $a^{n-1} \not\equiv 1 \pmod n$ alors $n$ est surement composé.
				\item $a^{n-1}\equiv 1 \pmod n$, on ne peut pas conclure avec certitude que $n$ est premier puisque la réciproque du théorème de Fermat est fausse. Un nombre $n$ vérifiant cette équation peut être premier, mais aussi composé, dans ce cas $n$ est dit \textit{\textbf{pseudo-premier} de base $a$}.
				\end{itemize}
				Les nombres pseudo-premiers sont relativement rares. On peut donc envisager d'adopter ce critère pour un test probabiliste de primalité, qui est le test de Fermat.
				
				\begin{algorithm}
					\caption{Test de Fermat\label{TF}}
					\Donnees{un entier n et le nombre de répétitions souhaitée k}
					\Pour{$i$ = $1$ jusqu'à $k$}{
						Choisir aléatoirement $a$ tel que $1 < a < n - 1$\;
						\Si {$a^{p-1} \not\equiv 1 \pmod n$}
							{\Retour composé\;}
				}
				\Retour premier\;
				\end{algorithm}
		
			\subsubsection{Complexité}
			\subsubsection{Preuve}
		
		\subsection{Test de Miller-Rabin}
		
		\subsection{AKS}
		
	\section{Mesures de performance et comparatifs}
	
		
	\section{Bilan technique du projet}
		Notre produit final, c'est à dire l'application, se comporte comme prévu : l'application est fonctionnelle, la liaison entre ses différents modules réussit bien et les différentes fonctionnalités fournissent le résultat attendu.		

		\subsection{Problèmes rencontrés}
			\subsubsection*{Problèmes résolus :} 
			Lors de la réalisation de l'application, on a été confrontés à plusieurs problèmes et points délicats, principalement des verrous techniques, qui ont perturbé le bon déroulement de notre travail :
				
			\subsubsection*{Problèmes non résolus :}
				Certains problèmes rencontrés n'ont pas été entièrement résolus. Ces problèmes ne sont pas déterminants pour l'acceptabilité de notre produit.
				
		\subsection{Organisation interne du groupe}
		Assignation des modules pour chaque membre du groupe :
		Cette répartition a été parfaitement respectée. Elle nous a permis de travailler efficacement et assez indépendamment, ce qui prouve que l'assignation des modules a été judicieusement faite. Nous sommes également restés en contact pendant toute la phase de développement pour s'entraider pour la prise en main des nouveaux outils.
	
		\subsection{Coûts}
		Ce tableau indique les coûts estimés et les coûts finaux, en nombre de lignes de code et pour chaque module :
	
	\section*{Conclusion}
		
\end{document}
