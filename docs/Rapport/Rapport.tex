\input{../tex/preambule}
\usepackage[french,frenchkw,ruled]{../tex/algorithm2e}

\title{\vspace{\fill}\textbf{\Huge Rapport}}
\author{
	Sonny Klotz - Idir Hamad - Younes Benyamna - Malek Zemni
	\vspace{2em}\\
	\textit{Projet M1 Informatique}\\\textit{Primalité}
	\vspace{2em}
}

\begin{document}
\pagenumbering{gobble}\clearpage
\maketitle\vspace{9em}
\begin{center}\includegraphics[scale=0.7]{logo.png}\end{center}
\begin{flushright}Module \textit{TER}\end{flushright}
\newpage
\tableofcontents
\newpage\clearpage\pagenumbering{arabic}

	\section*{Introduction}
	
	\paragraph{}Ce document est le compte-rendu final de notre projet sur les tests de primalité qui s'inscrit dans le cadre du module \textit{TER} du M1 informatique de l'\textit{UVSQ}.
	\paragraph{}Les tests de primalité sont des algorithmes qui permettent de savoir si un nombre entier est premier. Ces tests sont indispensables pour la cryptographie à clé publique.
	\paragraph{}Il existe plusieurs algorithmes de tests de primalité. L'efficacité de ces algorithmes est particulièrement liée au cryptosystème utilisé. 
	\paragraph{}Notre travail consiste donc à implémenter différents tests de primalité et de comparer leurs performances.
	\paragraph{}Dans la première partie de ce document, on présentera l'architecture de notre application, illustrée par un organigramme.\\
	Ensuite, on parlera des principaux cryptosystèmes faisant appel à des tests de primalité. \\
	La troisième partie traitera des différents algorithmes de tests de primalité implémentés.\\
	Les mesures de performance et le comparatif des tests de primalités seront détaillés dans la quatrième partie.\\
	Finalement, on établira un bilan technique de notre projet, quant à l'application, à l'organisation interne au sein du groupe et aux coûts.
	
	\section{Architecture de l'application}
		\subsection{Organigramme et données échangées}
		Cet organigramme représente la décomposition en modules de l'application, ainsi que les informations qui circulent entre ces modules.
		
		\subsection{Fonctionnalités des modules}
		
		\subsection{Outils et langages de programmation}
		Notre application va être implémentée dans le langage \lstinline!C!. Le langage \lstinline!C! possède plusieurs types pour représenter des nombre entiers. Cependant, tous ces types ont une précision fixe et ne peuvent pas dépasser un certain nombre d'octets. Le type le plus grand est le \lstinline!long long int! qui peut contenir des entiers d'un taille maximale de 64 bits. Or, tous ces types sont beaucoup trop courts pour les applications cryptographiques qui nécessitent la manipulation de données d'au moins 512 bits.
		\paragraph{}\lstinline!GNU MP! pour \lstinline!GNU Multi Precision!, souvent appelée \lstinline!GMP! est une bibliothèque \lstinline!C!/\lstinline!C++! de calcul multiprécision sur des nombres entiers, rationnels et à virgule flottante qui permet en particulier de manipuler de très grand nombres.
	
	\section{Cryptosystèmes}
		Les tests de primalité sont des algorithmes indispensables pour la cryptographie à clé publique. Ces tests sont couramment utilisés par les cryptosystèmes \textbf{\textit{RSA}} et \textbf{\textit{ElGamal}}.\\
		Pour \textit{RSA}, les tests sont effectués lors la phase de génération de clés. Pour \textit{ElGamal}, ils sont effectués lors de l'établissement d'un échange de clés.
		
		\subsection{RSA}
		
		\subsection{ElGamal}
		
		
	\section{Tests de primalité}
		Les tests de primalité sont des algorithmes qui permettent de savoir si un nombre entier est premier. Dans le cas où le nombre n'est pas premier, il est dit \textbf{\textit{composé}}. Dans cette partie, on va détailler les différents algorithmes de tests de primalité traités. Pour chaque test, on donnera un bref historique, l'algorithme du test, sa complexité et sa preuve, puis son implémentation.\\
		Les tests de primalité peuvent être
		\begin{itemize}
			\item \textbf{déterministes :} fournissent toujours la même réponse pour un nombre donné
			\item \textbf{probabilistes :} peuvent fournir des réponses différentes pour un même nombre (utilisent des données tirées aléatoirement)
		\end{itemize}
		
		\subsection{Test de Fermat}
			Le test de Fermat est un test de primalité probabiliste basé sur le \textit{petit théorème de Fermat}.
			\newtheorem*{Fermat}{Petit théorème de Fermat}
			\vspace{-1.5em}\begin{adjustwidth}{1.5cm}{1.5cm} 
			\begin{Fermat}
				si $p$ est un nombre premier, alors pour tout nombre entier $a$ premier avec $p$
				\[a^{p-1}\equiv 1 \pmod p\]
			\end{Fermat}
			\end{adjustwidth}\vspace{0.5em}
			
			\subsubsection{Algorithme}
				Le théorème de Fermat décrit une propriété commune à tous les nombres premiers qui peut être utilisée pour détecter si un nombre est premier ou bien composé.\\
				En effet, si pour un entier $a$ premier avec $n$ : 
				\begin{itemize}
				\item $a^{n-1} \not\equiv 1 \pmod n$ alors $n$ est surement composé.
				\item $a^{n-1}\equiv 1 \pmod n$, on ne peut pas conclure avec certitude que $n$ est premier puisque la réciproque du théorème de Fermat est fausse. Un nombre $n$ vérifiant cette équation peut être premier, mais aussi composé, dans ce cas $n$ est dit \textit{\textbf{pseudo-premier} de base $a$}.
				\end{itemize}
				Les nombres pseudo-premiers sont relativement rares. On peut donc envisager d'adopter ce critère pour un test probabiliste de primalité, qui est le test de Fermat.
				
				\begin{algorithm}
					\caption{Test de Fermat\label{TF}}
					\Donnees{un entier n et le nombre de répétitions souhaité k}
					\Pour{$i$ = $1$ jusqu'à $k$}{
						Choisir aléatoirement $a$ tel que $1 < a < n - 1$\;
						\Si {$a^{p-1} \not\equiv 1 \pmod n$}
							{\Retour composé\;}
				}
				\Retour premier\;
				\end{algorithm}
		
			\subsubsection{Complexité}
			\subsubsection{Preuve}
		
		\subsection{Test de Miller-Rabin}
			Le test de Miller-Rabin (probabiliste) est lui aussi basé sur le Petit Théorème de Fermat, mais exploite quant à lui quelques propriétés supplémentaires.
			Si $n$ est un nombre impair dont on souhaite tester la primalité, on peut écrire $n − 1 = 2s^{t}$, où $t$ est un nombre impair. 
			Dans le cas où $n$ est un nombre premier nous avons par le \textit{petit théorème de Fermat}:
				\begin{itemize}
				\item $1 \equiv a^{n-1} \pmod n$
				\item $\Leftrightarrow 0 \equiv a^{2^{s}t}-1 \pmod n$
				\end{itemize}
		
		\subsubsection{Algorithme}
			\begin{algorithm}
					\caption{Test de Miller-Rabin\label{TF}}
					\Donnees{un entier n et le nombre de répétitions souhaité k}
					\Pour{$i$ = $1$ jusqu'à $k$}{
						Choisir aléatoirement $a$ tel que $0 < a < n$\;
						$y\leftarrow a^{t} \pmod n$\;
						\Si {$y\not\equiv 1 \pmod n$ et $y\not\equiv -1 \pmod n$}
							\Pour{$j=1$ jusqu'à $s-1$}
								$y\leftarrow y^{2} \pmod n$\;
								\Si {$y\equiv 1 \pmod n$}
									{\Retour composé\;}
								\Si {$y\equiv -1 \pmod n$}
									{Arrêter la boucle de $j$. Continuer avec le $i$ suivant\;}
							{\Retour composé\;}
							}
					{\Retour premier\;}	
			\end{algorithm}
			
			Si le test de Miller-Rabin renvoie composé, alors le nombre est effectivement composé. 
			Il peut être démontré que si le test de Miller-Rabin dit que $n$ est premier, le résultat est faux avec une probabilité inférieure à 1/4. 
			En effet, il existe des valeurs de $a$ qui produiront de manière répétée des menteurs, qui indiqueront donc que $n$ est premier alors qu’il est composé. On appelle un témoin fort pour $n$ un entier $a$ pour lequel
				$a^{t}\not\equiv 1 \pmod n$ et $a^{2^{s}j}\not\equiv -1 \pmod n$ pour tous les $0\le j\le s-1$.
			Il peut être montré qu’il existe toujours un témoin fort pour n’importe quel composé impair $n$, et qu’au moins 3/4 de ces valeurs pour $a$ sont des témoins forts pour la composition de $n$. 
			Si on répète ce test $k$ fois, la probabilité que le résultat est toujours faux décroît très rapidement. La probabilité que le test renvoie premier à tort après $k$ itérations est $1$/${4^{k}}$.
			
		\subsubsection{Preuve}
		    Soit $n$ un nombre premier;
		    Nous avons par le \textit{petit théorème de Fermat}:
				\begin{itemize}
				\item $1 \equiv a^{n-1} \pmod n$
				\item $\Leftrightarrow 0 \equiv a^{2^{s}t}-1 \pmod n$
				
				
			 Puisque $s \geq 1$, le nombre  $a^{2^{s}t}$ = $(a^{2^{s-1}t})^{2}$ est un carré. Donc,
			  \item $a^{2^{s}t}-1$=($a^{2^{s-1}t}+1$)($a^{2^{s-1}t}-1$)\\
		
			Si $s-1 > 0$ alors le dernier terme est de nouveau une différence de carrés qui peut être donc factorisée.
            En continuant de la même manière, on obtient au final l'expression suivante :\\
            $0\equiv ($a^{2^{s-1}t}+1$)($a^{2^{s-2}t}+1$) ... ($a^{t}+1$)($a^{t}-1$)  \pmod n$.           (1)\\
            \\
            On sait maintenant que pour un nombre premier $p$, si $ab\equiv 0 \pmod p$ alors $a\equiv 0 \pmod p$ ou $b\equiv 0 \pmod p$
            Par conséquent, si $n$ est premier, alors l'équation (1) est vraie si et seulement si un des termes de la partie droite est $0 \pmod n$. Autrement dit, si $n$ est premier alors:
            
            \item $a^{2^{j}t} \equiv -1 \pmod n$, pour au moins un $j=0, ..., s-1$\\
            ou
            \item $a^{t} \equiv 1 \pmod n$\\
            
            Si pour un nombre entier $n$, une des équations ci-dessus est vérifiée, alors l'algorithme conclue que $n$ est probablement premier et termine.\\
            Si aucune de ces équations n'est vérifiée, alors l'algorithme renvoie que $n$ est composé. 
            Nous pouvons maintenant apporter à cette première approche l'amélioration suivante.\\
            
            Si on trouve que
            \item $a^{2^{j}t} \equiv 1 \pmod n$\\
            pour un $j=0, ..., s-1$, on peut directement conclure que $n$ est composé et terminer l'exécution de l'algorithme. Ceci est basé sur le fait que si $p$ est premier, les seuls éléments pour lesquels $x^{2} \equiv 1 \pmod p$ sont $1$ et $-1$. Or, $1$ et $-1$ sont les deux seuls racines carrés de l'unité.\\
            La version du test de Miller-Rabin, prenant en compte cette dernière astuce est décrite par l'algorithme ci-dessus.
            
        
			\end{itemize}
		\subsubsection{Compléxité}
		
		
		\subsection{AKS}
		
	\section{Mesures de performance et comparatifs}
	
		
	\section{Bilan technique du projet}
		Notre produit final, c'est à dire l'application, se comporte comme prévu : l'application est fonctionnelle, la liaison entre ses différents modules réussit bien et les différentes fonctionnalités fournissent le résultat attendu.		

		\subsection{Problèmes rencontrés}
			\subsubsection*{Problèmes résolus :} 
			Lors de la réalisation de l'application, on a été confrontés à plusieurs problèmes et points délicats, principalement des verrous techniques, qui ont perturbé le bon déroulement de notre travail :
				
			\subsubsection*{Problèmes non résolus :}
				Certains problèmes rencontrés n'ont pas été entièrement résolus. Ces problèmes ne sont pas déterminants pour l'acceptabilité de notre produit.
				
		\subsection{Organisation interne du groupe}
		Assignation des modules pour chaque membre du groupe :
		Cette répartition a été parfaitement respectée. Elle nous a permis de travailler efficacement et assez indépendamment, ce qui prouve que l'assignation des modules a été judicieusement faite. Nous sommes également restés en contact pendant toute la phase de développement pour s'entraider pour la prise en main des nouveaux outils.
	
		\subsection{Coûts}
		Ce tableau indique les coûts estimés et les coûts finaux, en nombre de lignes de code et pour chaque module :
	
	\section*{Conclusion}
		
\end{document}
